<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>David & Ice Cream — Quest</title>

  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">

  <style>
    :root{
      --ui-text: rgba(255,255,255,0.92);
    }
    *{ box-sizing:border-box; margin:0; padding:0; }
    html, body { height:100%; }
    body{
      font-family: "Press Start 2P", monospace;
      color: var(--ui-text);
      background: url("fon.png") center/cover no-repeat fixed;
      overflow:hidden;
    }

    .screen{ position:fixed; inset:0; display:flex; align-items:center; justify-content:center; padding:24px; }
    .hidden{ display:none !important; }
    .screen::before{
      content:""; position:absolute; inset:0;
      background: radial-gradient(1200px 700px at 50% 40%, rgba(0,0,0,0.18), rgba(0,0,0,0.58));
      pointer-events:none;
    }

    .card{
      position:relative;
      width:min(920px, 94vw);
      background: linear-gradient(180deg, rgba(22,26,38,0.92), rgba(10,12,18,0.86));
      border:1px solid rgba(255,255,255,0.16);
      border-radius:18px;
      box-shadow: 0 20px 85px rgba(0,0,0,0.55);
      overflow:hidden;
    }
    .card-inner{ padding:26px 22px; display:grid; grid-template-columns: 1fr; gap:16px; }

    .intro-hero{
      display:flex; flex-direction:column; align-items:center; text-align:center;
      gap:16px; padding:18px 14px 6px 14px;
    }
    .intro-hero img{
      width:min(360px, 62vw);
      height:auto;
      image-rendering: pixelated;
      filter: drop-shadow(0 10px 18px rgba(0,0,0,0.45));
    }
    .intro-text{ font-size: 11px; line-height: 1.65; opacity:0.98; padding: 0 10px 10px 10px; }

    .button-row{ display:flex; gap:12px; justify-content:center; flex-wrap:wrap; padding-bottom: 18px; }

    .btn{
      font-family: inherit;
      font-size: 12px;
      padding: 12px 14px;
      border-radius: 12px;
      border: 1px solid rgba(255,255,255,0.16);
      color: rgba(255,255,255,0.92);
      background: linear-gradient(135deg, rgba(180,108,255,0.22), rgba(95,225,255,0.16));
      cursor:pointer;
      text-transform: uppercase;
      letter-spacing: 0.5px;
      transition: transform 0.12s ease, filter 0.2s ease, border-color 0.2s ease;
      user-select:none;
    }
    .btn:hover{ transform: translateY(-2px); border-color: rgba(255,255,255,0.28); filter: brightness(1.06); }
    .btn:active{ transform: translateY(0px); }
    .btn-danger{ background: linear-gradient(135deg, rgba(255,77,109,0.24), rgba(180,108,255,0.14)); }
    .btn-ghost{ background: rgba(255,255,255,0.06); }

    #hud{
      position:fixed;
      top:14px; left:50%;
      transform: translateX(-50%);
      width:min(1100px, 94vw);
      display:flex; align-items:center; justify-content:space-between;
      gap:12px;
      padding: 12px 12px;
      background: rgba(8,10,16,0.55);
      border:1px solid rgba(255,255,255,0.14);
      border-radius: 14px;
      backdrop-filter: blur(8px);
      z-index:10;
    }
    .hud-block{ display:flex; flex-direction:column; gap:6px; min-width: 210px; }
    .hud-line{
      display:flex; align-items:center; justify-content:space-between; gap:12px;
      font-size:10px; color: rgba(255,255,255,0.82); white-space:nowrap;
    }
    .progress-wrap{ flex:1; min-width: 260px; display:flex; flex-direction:column; gap:8px; }
    .progress-bar{
      width:100%; height: 12px; border-radius: 999px;
      background: rgba(255,255,255,0.10);
      border: 1px solid rgba(255,255,255,0.14);
      overflow:hidden;
    }
    .progress-fill{ height:100%; width:0%; background: linear-gradient(90deg, rgba(180,108,255,0.85), rgba(95,225,255,0.85)); }

    #game{ position:fixed; inset:0; width:100vw; height:100vh; display:block; z-index:1; }

    .overlay{ position:fixed; inset:0; display:flex; align-items:center; justify-content:center; padding:24px; z-index:20; }
    .overlay::before{ content:""; position:absolute; inset:0; background: rgba(0,0,0,0.55); backdrop-filter: blur(6px); }

    .panel{
      position:relative;
      width:min(820px, 94vw);
      background: linear-gradient(180deg, rgba(22,26,38,0.92), rgba(10,12,18,0.86));
      border:1px solid rgba(255,255,255,0.16);
      border-radius:18px;
      box-shadow: 0 20px 85px rgba(0,0,0,0.55);
      padding: 22px 18px;
    }
    .panel h2{ font-size: 13px; line-height:1.4; margin-bottom: 14px; color: rgba(255,255,255,0.94); }
    .panel p{ font-size: 10px; line-height:1.8; color: rgba(255,255,255,0.82); margin-bottom: 16px; }
    .panel .meta{ font-size: 10px; line-height:1.8; color: rgba(255,255,255,0.72); margin-bottom: 18px; }
    .panel-actions{ display:flex; gap:12px; justify-content:flex-start; flex-wrap:wrap; }

    .level-grid{ display:grid; grid-template-columns: repeat(3, minmax(0, 1fr)); gap:12px; padding: 6px 0 4px 0; }
    .level-grid .btn{ width:100%; }

    @media (max-width: 820px){ .level-grid{ grid-template-columns: repeat(2, minmax(0, 1fr)); } }
    @media (max-width: 520px){ .level-grid{ grid-template-columns: 1fr; } }

    #levelsGrid .btn{ display:flex; align-items:center; justify-content:space-between; gap:12px; }
    .lvl-badge{
      font-size:9px; padding:6px 10px; border-radius:999px;
      border:1px solid rgba(255,255,255,0.18);
      background: rgba(255,255,255,0.08);
      color: rgba(255,255,255,0.78);
      white-space: nowrap;
    }
    .lvl-badge.done{
      background: rgba(55, 214, 122, 0.16);
      border-color: rgba(55, 214, 122, 0.32);
      color: rgba(180, 255, 205, 0.95);
    }
    .lvl-badge.todo{
      background: rgba(255,255,255,0.07);
      border-color: rgba(255,255,255,0.16);
      color: rgba(255,255,255,0.76);
    }
  </style>
</head>

<body>
  <section id="intro" class="screen">
    <div class="card">
      <div class="card-inner">
        <div class="intro-hero">
          <img src="1.png" alt="Intro image" />
          <div class="intro-text">
            You probably remember that back in December David got upset because he couldn’t taste ice cream.
            Now this is a game — a whole campaign dedicated to David and ice cream.
            A long journey awaits...
          </div>
        </div>
        <div class="button-row">
          <button id="btnStart" class="btn">./ START</button>
        </div>
      </div>
    </div>
  </section>

  <section id="levelSelect" class="screen hidden">
    <div class="card">
      <div class="card-inner">
        <div class="intro-hero" style="padding-bottom:0;">
          <div style="font-size:13px; line-height:1.5;">SELECT LEVEL</div>
          <div class="intro-text" style="padding-bottom:0;">
            Choose a level. Each level starts only after you press its button.
          </div>
        </div>

        <div style="display:flex; flex-direction:column; gap:12px;">
          <div style="display:flex; align-items:center; justify-content:space-between; gap:12px;">
            <div style="font-size:10px; color:rgba(255,255,255,0.82);">PROGRESS</div>
            <div id="levelsProgressText" style="font-size:10px; color:rgba(255,255,255,0.82);">0 / 12</div>
          </div>
          <div style="height:12px; border-radius:999px; background:rgba(255,255,255,0.10); border:1px solid rgba(255,255,255,0.14); overflow:hidden;">
            <div id="levelsProgressFill" style="height:100%; width:0%; background:linear-gradient(90deg, rgba(180,108,255,0.85), rgba(95,225,255,0.85));"></div>
          </div>

          <div class="level-grid" id="levelsGrid">
            <button class="btn" data-level="0"><span>./ LEVEL 1</span><span data-status class="lvl-badge todo">NOT DONE</span></button>
            <button class="btn" data-level="1"><span>./ LEVEL 2</span><span data-status class="lvl-badge todo">NOT DONE</span></button>
            <button class="btn" data-level="2"><span>./ LEVEL 3</span><span data-status class="lvl-badge todo">NOT DONE</span></button>
            <button class="btn" data-level="3"><span>./ LEVEL 4</span><span data-status class="lvl-badge todo">NOT DONE</span></button>
            <button class="btn" data-level="4"><span>./ LEVEL 5</span><span data-status class="lvl-badge todo">NOT DONE</span></button>
            <button class="btn" data-level="5"><span>./ LEVEL 6</span><span data-status class="lvl-badge todo">NOT DONE</span></button>
            <button class="btn" data-level="6"><span>./ LEVEL 7</span><span data-status class="lvl-badge todo">NOT DONE</span></button>
            <button class="btn" data-level="7"><span>./ LEVEL 8</span><span data-status class="lvl-badge todo">NOT DONE</span></button>
            <button class="btn" data-level="8"><span>./ LEVEL 9</span><span data-status class="lvl-badge todo">NOT DONE</span></button>
            <button class="btn" data-level="9"><span>./ LEVEL 10</span><span data-status class="lvl-badge todo">NOT DONE</span></button>
            <button class="btn" data-level="10"><span>./ LEVEL 11</span><span data-status class="lvl-badge todo">NOT DONE</span></button>
            <button class="btn" data-level="11"><span>./ LEVEL 12</span><span data-status class="lvl-badge todo">NOT DONE</span></button>
          </div>
        </div>

        <div class="button-row">
          <button id="btnBackToIntro" class="btn btn-ghost">./ MENU</button>
        </div>
      </div>
    </div>
  </section>

  <canvas id="game" class="hidden"></canvas>

  <div id="hud" class="hidden">
    <div class="hud-block">
      <div class="hud-line"><span>LEVEL</span><span id="hudLevel">1 / 12</span></div>
      <div class="hud-line"><span>TIME</span><span id="hudTime">00.0</span></div>
    </div>

    <div class="progress-wrap">
      <div class="hud-line"><span>PROGRESS</span><span id="hudProgressText">0%</span></div>
      <div class="progress-bar"><div id="hudProgressFill" class="progress-fill"></div></div>
    </div>

    <div class="hud-block">
      <div class="hud-line"><span>GOAL</span><span id="hudGoal">—</span></div>
      <div class="hud-line"><span>COLLECTED</span><span id="hudCollected">0</span></div>
    </div>
  </div>

  <div id="levelOverlay" class="overlay hidden">
    <div class="panel">
      <h2 id="levelTitle">LEVEL 1</h2>
      <p id="levelTask">Task text…</p>
      <div class="panel-actions">
        <button id="btnLevelGo" class="btn">./ LEVEL 1</button>
        <button id="btnBackMenuFromLevel" class="btn btn-ghost">./ LEVELS</button>
      </div>
    </div>
  </div>

  <div id="gameOverOverlay" class="overlay hidden">
    <div class="panel">
      <h2 id="gameOverTitle">GAME OVER</h2>
      <p id="gameOverReason">You failed the task.</p>
      <div class="meta" id="gameOverMeta">—</div>
      <div class="panel-actions">
        <button id="btnRestart" class="btn btn-danger">./ RESTART</button>
        <button id="btnLevels" class="btn btn-ghost">./ LEVELS</button>
      </div>
    </div>
  </div>

  <script>
    function loadImage(src){
      return new Promise((resolve, reject) => {
        const img = new Image();
        img.onload = () => resolve(img);
        img.onerror = () => reject(new Error("Failed to load " + src));
        img.src = src;
      });
    }

    const ASSETS = {
      player: "david.png",
      white: "icecream-1.png",
      purple: "icecream-2.png",
      yellow: "icecream-3.png",
      blue: "icecream-4.png",
    };

    const ui = {
      intro: document.getElementById("intro"),
      levelSelect: document.getElementById("levelSelect"),
      canvas: document.getElementById("game"),
      hud: document.getElementById("hud"),

      hudLevel: document.getElementById("hudLevel"),
      hudTime: document.getElementById("hudTime"),
      hudGoal: document.getElementById("hudGoal"),
      hudCollected: document.getElementById("hudCollected"),
      hudProgressText: document.getElementById("hudProgressText"),
      hudProgressFill: document.getElementById("hudProgressFill"),

      levelOverlay: document.getElementById("levelOverlay"),
      levelTitle: document.getElementById("levelTitle"),
      levelTask: document.getElementById("levelTask"),
      btnLevelGo: document.getElementById("btnLevelGo"),
      btnBackMenuFromLevel: document.getElementById("btnBackMenuFromLevel"),

      gameOverOverlay: document.getElementById("gameOverOverlay"),
      gameOverTitle: document.getElementById("gameOverTitle"),
      gameOverReason: document.getElementById("gameOverReason"),
      gameOverMeta: document.getElementById("gameOverMeta"),

      btnStart: document.getElementById("btnStart"),
      btnBackToIntro: document.getElementById("btnBackToIntro"),
      btnRestart: document.getElementById("btnRestart"),
      btnLevels: document.getElementById("btnLevels"),
    };

    const LEVELS = [
      { name:"LEVEL 1", task:"Your mission: collect 10 white ice creams in 30 seconds.", timeLimit:30,
        goal:{white:10,purple:0,yellow:0,blue:0}, surviveSeconds:0,
        forbidden:{purple:false,yellow:false,white:false,blue:false},
        enemies:{white:0,purple:0,yellow:0,blue:0}, spawn:{white:12,purple:0,yellow:0,blue:0},
      },
      { name:"LEVEL 2", task:"Collect 10 purple ice creams in 20 seconds.", timeLimit:20,
        goal:{white:0,purple:10,yellow:0,blue:0}, surviveSeconds:0,
        forbidden:{purple:false,yellow:false,white:false,blue:false},
        enemies:{white:0,purple:0,yellow:0,blue:0}, spawn:{white:0,purple:12,yellow:0,blue:0},
      },
      { name:"LEVEL 3", task:"Collect 5 yellow ice creams — but if you touch purple ice cream, you lose.", timeLimit:9999,
        goal:{white:0,purple:0,yellow:5,blue:0}, surviveSeconds:0,
        forbidden:{purple:true,yellow:false,white:false,blue:false},
        enemies:{white:0,purple:2,yellow:0,blue:0}, spawn:{white:0,purple:3,yellow:8,blue:0},
      },
      { name:"LEVEL 4", task:"Collect 12 yellow ice creams.", timeLimit:9999,
        goal:{white:0,purple:0,yellow:12,blue:0}, surviveSeconds:0,
        forbidden:{purple:false,yellow:false,white:false,blue:false},
        enemies:{white:0,purple:0,yellow:0,blue:0}, spawn:{white:0,purple:0,yellow:16,blue:0},
      },
      { name:"LEVEL 5", task:"Collect 30 yellow ice creams", timeLimit:9999,
        goal:{white:0,purple:0,yellow:30,blue:0}, surviveSeconds:0,
        forbidden:{purple:false,yellow:false,white:false,blue:false},
        enemies:{white:0,purple:0,yellow:0,blue:0}, spawn:{white:0,purple:0,yellow:34,blue:0},
      },
      { name:"LEVEL 6", task:"Collect 20 white ice creams. Two enemies are chasing you.", timeLimit:9999,
        goal:{white:20,purple:0,yellow:0,blue:0}, surviveSeconds:0,
        forbidden:{purple:false,yellow:false,white:false,blue:false},
        enemies:{white:0,purple:2,yellow:0,blue:0}, spawn:{white:24,purple:0,yellow:0,blue:0},
      },
      { name:"LEVEL 7", task:"15 yellow ice creams are enemies. Collect 5 white ice creams to win.", timeLimit:9999,
        goal:{white:5,purple:0,yellow:0,blue:0}, surviveSeconds:0,
        forbidden:{purple:false,yellow:false,white:false,blue:false},
        enemies:{white:0,purple:0,yellow:15,blue:0}, spawn:{white:8,purple:0,yellow:0,blue:0},
      },
      { name:"LEVEL 8", task:"20 white ice creams are enemies. Survive 20 seconds to win.", timeLimit:20,
        goal:{white:0,purple:0,yellow:0,blue:0}, surviveSeconds:20,
        forbidden:{purple:false,yellow:false,white:false,blue:false},
        enemies:{white:20,purple:0,yellow:0,blue:0}, spawn:{white:0,purple:0,yellow:0,blue:0},
      },
      { name:"LEVEL 9", task:"Collect 2 purple ice creams. 25 blue ice creams are enemies.", timeLimit:9999,
        goal:{white:0,purple:2,yellow:0,blue:0}, surviveSeconds:0,
        forbidden:{purple:false,yellow:false,white:false,blue:false},
        enemies:{white:0,purple:0,yellow:0,blue:25}, spawn:{white:0,purple:4,yellow:0,blue:0},
      },

      { name:"LEVEL 10", task:"30 blue enemies. Collect 5 white ice creams.", timeLimit:9999,
        goal:{white:5,purple:0,yellow:0,blue:0}, surviveSeconds:0,
        forbidden:{purple:false,yellow:false,white:false,blue:false},
        enemies:{white:0,purple:0,yellow:0,blue:30}, spawn:{white:5,purple:0,yellow:0,blue:0},
      },

      { name:"LEVEL 11", task:"Survive 20 seconds. 20 yellow enemies chase you like a magnet — touch = lose. You are slightly faster.",
        timeLimit:20, goal:{white:0,purple:0,yellow:0,blue:0}, surviveSeconds:20,
        forbidden:{purple:false,yellow:false,white:false,blue:false},
        enemies:{white:0,purple:0,yellow:20,blue:0}, spawn:{white:0,purple:0,yellow:0,blue:0},
        enemyBehavior:{ mode:"magnet", magnetStrength:260, speedCap:360 },   
        playerSpeedOverride: 420,                                          
      },

      { name:"LEVEL 12", task:"Purple ice creams appear one by one. Collect 6 purple ice creams. Avoid 20 blue enemies.",
        timeLimit:9999, goal:{white:0,purple:6,yellow:0,blue:0}, surviveSeconds:0,
        forbidden:{purple:false,yellow:false,white:false,blue:false},
        enemies:{white:0,purple:0,yellow:0,blue:20},         
        spawn:{white:0,purple:0,yellow:0,blue:0},
        sequential:{ type:"purple", total:6 },
      },
    ];

    const SAVE_KEY = "david_icecream_levels_done_v5";

    function loadDoneArray(){
      try{
        const raw = localStorage.getItem(SAVE_KEY);
        const arr = raw ? JSON.parse(raw) : [];
        const out = new Array(LEVELS.length).fill(false);
        if (Array.isArray(arr)){
          for (let i=0; i<out.length; i++) out[i] = !!arr[i];
        }
        return out;
      }catch(e){
        return new Array(LEVELS.length).fill(false);
      }
    }
    function saveDoneArray(done){ localStorage.setItem(SAVE_KEY, JSON.stringify(done)); }

    function renderLevelsProgressUI(){
      const grid = document.getElementById("levelsGrid");
      const text = document.getElementById("levelsProgressText");
      const fill = document.getElementById("levelsProgressFill");
      if (!grid || !text || !fill) return;

      const total = LEVELS.length;
      const doneCount = STATE.doneLevels.filter(Boolean).length;

      text.textContent = `${doneCount} / ${total}`;
      fill.style.width = `${Math.round((doneCount / Math.max(1,total)) * 100)}%`;

      [...grid.querySelectorAll("button[data-level]")].forEach((btn) => {
        const idx = Number(btn.getAttribute("data-level"));
        const badge = btn.querySelector("[data-status]");
        if (!badge || !Number.isFinite(idx)) return;

        const isDone = !!STATE.doneLevels[idx];
        badge.textContent = isDone ? "DONE" : "NOT DONE";
        badge.classList.toggle("done", isDone);
        badge.classList.toggle("todo", !isDone);
      });
    }

    const STATE = {
      assetsReady: false,
      imgs: {},

      running: false,
      currentLevelIndex: 0,

      timeLeft: 0,
      timeSurvived: 0,
      lastT: 0,

      ctx: null,
      w: 0,
      h: 0,

      keys: new Set(),

      basePlayer: { x: 0, y: 0, r: 26, speed: 420 },
      player: { x: 0, y: 0, r: 26, speed: 420 },

      pickups: [],
      collected: { white:0, purple:0, yellow:0, blue:0 },

      seqRemaining: 0,
      flashT: 0,

      doneLevels: loadDoneArray(),
    };

    function clamp(v, a, b){ return Math.max(a, Math.min(b, v)); }
    function rand(a,b){ return a + Math.random()*(b-a); }
    function dist2(ax,ay,bx,by){ const dx=ax-bx, dy=ay-by; return dx*dx+dy*dy; }

    function show(el){ el.classList.remove("hidden"); }
    function hide(el){ el.classList.add("hidden"); }

    function showIntro(){
      STATE.running = false;
      hide(ui.canvas); hide(ui.hud); hide(ui.levelOverlay); hide(ui.gameOverOverlay); hide(ui.levelSelect);
      show(ui.intro);
    }
    function showGameScene(){
      hide(ui.intro); hide(ui.levelSelect);
      show(ui.canvas); show(ui.hud);
    }
    function showLevelsMenu(){
      STATE.running = false;
      hide(ui.levelOverlay); hide(ui.gameOverOverlay); hide(ui.canvas); hide(ui.hud); hide(ui.intro);
      show(ui.levelSelect);
      renderLevelsProgressUI();
    }
    function showLevelOverlay(levelIndex){
      const lvl = LEVELS[levelIndex];
      ui.levelTitle.textContent = lvl.name;
      ui.levelTask.textContent = lvl.task;
      ui.btnLevelGo.textContent = "./ " + lvl.name;
      show(ui.levelOverlay);
    }
    function hideLevelOverlay(){ hide(ui.levelOverlay); }

    function showGameOver(reason){
      STATE.running = false;
      ui.gameOverTitle.textContent = "GAME OVER";
      ui.gameOverReason.textContent = reason;

      const lvl = LEVELS[STATE.currentLevelIndex];
      const collectedLine = `Collected: W ${STATE.collected.white} / P ${STATE.collected.purple} / Y ${STATE.collected.yellow} / B ${STATE.collected.blue}`;
      const surviveLine = lvl.surviveSeconds ? ` | Survived: ${STATE.timeSurvived.toFixed(1)}s / ${lvl.surviveSeconds}s` : "";
      ui.gameOverMeta.textContent = `${lvl.name} — ${collectedLine}${surviveLine}`;

      show(ui.gameOverOverlay);
    }

    function spawnOne(type, isEnemy=false){
      const r = 20;
      let x = rand(40, STATE.w - 40);
      let y = rand(90, STATE.h - 60);

      if (dist2(x,y,STATE.player.x,STATE.player.y) < 180*180){
        x = rand(40, STATE.w - 40);
        y = rand(90, STATE.h - 60);
      }

      const baseV = isEnemy ? rand(130, 190) : rand(40, 85);
      const a = rand(0, Math.PI*2);

      STATE.pickups.push({ type, x, y, r, vx: Math.cos(a)*baseV, vy: Math.sin(a)*baseV, isEnemy });
    }

    function spawnPickupsForLevel(lvl){
      const spawn = lvl.spawn || {};
      if (spawn.white) for (let i=0;i<spawn.white;i++) spawnOne("white", false);
      if (spawn.purple) for (let i=0;i<spawn.purple;i++) spawnOne("purple", false);
      if (spawn.yellow) for (let i=0;i<spawn.yellow;i++) spawnOne("yellow", false);
      if (spawn.blue) for (let i=0;i<spawn.blue;i++) spawnOne("blue", false);

      const enemies = lvl.enemies || {};
      if (enemies.white) for (let i=0;i<enemies.white;i++) spawnOne("white", true);
      if (enemies.purple) for (let i=0;i<enemies.purple;i++) spawnOne("purple", true);
      if (enemies.yellow) for (let i=0;i<enemies.yellow;i++) spawnOne("yellow", true);
      if (enemies.blue) for (let i=0;i<enemies.blue;i++) spawnOne("blue", true);

      if (lvl.sequential && lvl.sequential.type){
        STATE.seqRemaining = Number(lvl.sequential.total || 0);
        if (STATE.seqRemaining > 0){
          spawnOne(lvl.sequential.type, false);
        }
      }
    }

    function resetForLevel(levelIndex){
      STATE.currentLevelIndex = levelIndex;
      STATE.pickups = [];
      STATE.collected = { white:0, purple:0, yellow:0, blue:0 };
      STATE.timeSurvived = 0;
      STATE.seqRemaining = 0;

      // set player speed per level (LEVEL 11 override)
      const lvl = LEVELS[levelIndex];
      STATE.player.speed = Number(lvl.playerSpeedOverride || STATE.basePlayer.speed);

      STATE.player.x = STATE.w * 0.5;
      STATE.player.y = STATE.h * 0.62;

      STATE.timeLeft = lvl.timeLimit;
      spawnPickupsForLevel(lvl);
      updateHUD();
    }

    function levelGoalTotal(lvl){
      const g = lvl.goal || {};
      const base = (g.white||0) + (g.purple||0) + (g.yellow||0) + (g.blue||0);
      if (lvl.surviveSeconds && lvl.surviveSeconds > 0) return Math.max(1, base + 1);
      return Math.max(1, base);
    }

    function levelCollectedForGoal(lvl){
      const g = lvl.goal || {};
      let sum = 0;
      if (g.white) sum += Math.min(STATE.collected.white, g.white);
      if (g.purple) sum += Math.min(STATE.collected.purple, g.purple);
      if (g.yellow) sum += Math.min(STATE.collected.yellow, g.yellow);
      if (g.blue) sum += Math.min(STATE.collected.blue, g.blue);

      if (lvl.surviveSeconds && lvl.surviveSeconds > 0){
        sum += (STATE.timeSurvived >= lvl.surviveSeconds) ? 1 : 0;
      }
      return sum;
    }

    function checkWin(){
      const lvl = LEVELS[STATE.currentLevelIndex];
      const g = lvl.goal || {};
      const okWhite = (STATE.collected.white >= (g.white||0));
      const okPurple = (STATE.collected.purple >= (g.purple||0));
      const okYellow = (STATE.collected.yellow >= (g.yellow||0));
      const okBlue = (STATE.collected.blue >= (g.blue||0));
      const okSurvive = (!lvl.surviveSeconds || lvl.surviveSeconds <= 0) ? true : (STATE.timeSurvived >= lvl.surviveSeconds);
      return okWhite && okPurple && okYellow && okBlue && okSurvive;
    }

    function winAndPromptNext(){
      STATE.doneLevels[STATE.currentLevelIndex] = true;
      saveDoneArray(STATE.doneLevels);

      if (STATE.currentLevelIndex + 1 < LEVELS.length){
        const nextIndex = STATE.currentLevelIndex + 1;
        resetForLevel(nextIndex);
        showLevelOverlay(nextIndex);
        STATE.running = false;
      } else {
        STATE.running = false;
        ui.gameOverTitle.textContent = "YOU WIN";
        ui.gameOverReason.textContent = "Campaign complete. David finally gets the ice cream.";
        ui.gameOverMeta.textContent = `Finished: ${LEVELS.length} levels.`;
        show(ui.gameOverOverlay);
      }
    }

    function applyEnemyChase(dt, lvl, p){
      let strength = 40;
      let cap = 230;

      const eb = lvl.enemyBehavior || null;
      if (eb && eb.mode === "magnet"){
        strength = Number(eb.magnetStrength ?? 260);
        cap = Number(eb.speedCap ?? 360);
      }

      const dx = STATE.player.x - p.x;
      const dy = STATE.player.y - p.y;
      const d = Math.hypot(dx,dy) || 1;

      p.vx += (dx/d) * strength * dt;
      p.vy += (dy/d) * strength * dt;

      const sp = Math.hypot(p.vx,p.vy);
      if (sp > cap){
        p.vx = p.vx / sp * cap;
        p.vy = p.vy / sp * cap;
      }
    }

    function resizeCanvas(){
      const dpr = Math.max(1, Math.min(2, window.devicePixelRatio || 1));
      STATE.w = window.innerWidth;
      STATE.h = window.innerHeight;

      ui.canvas.width = Math.floor(STATE.w * dpr);
      ui.canvas.height = Math.floor(STATE.h * dpr);
      ui.canvas.style.width = STATE.w + "px";
      ui.canvas.style.height = STATE.h + "px";

      STATE.ctx.setTransform(dpr,0,0,dpr,0,0);
    }

    function update(dt){
      const lvl = LEVELS[STATE.currentLevelIndex];

      if (lvl.surviveSeconds && lvl.surviveSeconds > 0){
        STATE.timeSurvived += dt;
      }

      if (lvl.timeLimit < 9000){
        STATE.timeLeft -= dt;
        if (STATE.timeLeft <= 0){
          STATE.timeLeft = 0;
          if (checkWin()){ winAndPromptNext(); return; }
          showGameOver("Time is up.");
          return;
        }
      }

      let mx = 0, my = 0;
      if (STATE.keys.has("ArrowLeft") || STATE.keys.has("a") || STATE.keys.has("A")) mx -= 1;
      if (STATE.keys.has("ArrowRight") || STATE.keys.has("d") || STATE.keys.has("D")) mx += 1;
      if (STATE.keys.has("ArrowUp") || STATE.keys.has("w") || STATE.keys.has("W")) my -= 1;
      if (STATE.keys.has("ArrowDown") || STATE.keys.has("s") || STATE.keys.has("S")) my += 1;

      const len = Math.hypot(mx,my) || 1;
      mx /= len; my /= len;

      STATE.player.x += mx * STATE.player.speed * dt;
      STATE.player.y += my * STATE.player.speed * dt;
      STATE.player.x = clamp(STATE.player.x, 28, STATE.w - 28);
      STATE.player.y = clamp(STATE.player.y, 72, STATE.h - 28);

      for (const p of STATE.pickups){
        p.x += p.vx * dt;
        p.y += p.vy * dt;

        const pad = 26;
        if (p.x < pad){ p.x = pad; p.vx *= -1; }
        if (p.x > STATE.w - pad){ p.x = STATE.w - pad; p.vx *= -1; }
        if (p.y < 72){ p.y = 72; p.vy *= -1; }
        if (p.y > STATE.h - pad){ p.y = STATE.h - pad; p.vy *= -1; }

        if (p.isEnemy){
          applyEnemyChase(dt, lvl, p);
        }
      }

      for (let i = STATE.pickups.length - 1; i >= 0; i--){
        const p = STATE.pickups[i];
        const rr = (STATE.player.r + p.r);
        if (dist2(STATE.player.x, STATE.player.y, p.x, p.y) <= rr*rr){

          if (p.isEnemy){
            showGameOver("You touched an enemy.");
            return;
          }

          if (lvl.forbidden && lvl.forbidden[p.type]){
            showGameOver("You touched a forbidden ice cream.");
            return;
          }

          STATE.pickups.splice(i, 1);
          if (p.type === "white") STATE.collected.white++;
          if (p.type === "purple") STATE.collected.purple++;
          if (p.type === "yellow") STATE.collected.yellow++;
          if (p.type === "blue") STATE.collected.blue++;
          STATE.flashT = 0.08;

          if (lvl.sequential && !p.isEnemy && p.type === lvl.sequential.type){
            STATE.seqRemaining = Math.max(0, STATE.seqRemaining - 1);
            if (STATE.seqRemaining > 0){
              spawnOne(lvl.sequential.type, false);
            }
          }

          if (checkWin()){
            winAndPromptNext();
            return;
          }
        }
      }

      if (lvl.surviveSeconds && lvl.surviveSeconds > 0 && STATE.timeSurvived >= lvl.surviveSeconds){
        if (checkWin()){ winAndPromptNext(); return; }
      }

      STATE.flashT = Math.max(0, STATE.flashT - dt);
    }

    function draw(){
      const ctx = STATE.ctx;
      ctx.clearRect(0,0,STATE.w,STATE.h);

      for (const p of STATE.pickups) drawIceCream(p);
      drawPlayer();

      if (STATE.flashT > 0){
        ctx.save();
        ctx.globalAlpha = Math.min(0.25, STATE.flashT * 4);
        ctx.fillStyle = "white";
        ctx.fillRect(0,0,STATE.w,STATE.h);
        ctx.restore();
      }
    }

    function drawPlayer(){
      const ctx = STATE.ctx;
      const img = STATE.imgs.player;
      const size = 78;

      const t = performance.now() * 0.002;
      const bob = Math.sin(t) * 2;

      ctx.save();
      ctx.translate(STATE.player.x, STATE.player.y + bob);

      ctx.globalAlpha = 0.35;
      ctx.fillStyle = "black";
      ctx.beginPath();
      ctx.ellipse(0, size*0.46, size*0.32, size*0.14, 0, 0, Math.PI*2);
      ctx.fill();
      ctx.globalAlpha = 1;

      ctx.imageSmoothingEnabled = true;
      ctx.drawImage(img, -size/2, -size/2, size, size);
      ctx.restore();
    }

    function drawIceCream(p){
      const ctx = STATE.ctx;
      let img = STATE.imgs.white;
      if (p.type === "white") img = STATE.imgs.white;
      if (p.type === "purple") img = STATE.imgs.purple;
      if (p.type === "yellow") img = STATE.imgs.yellow;
      if (p.type === "blue") img = STATE.imgs.blue;

      const size = p.isEnemy ? 62 : 54;

      if (p.isEnemy){
        ctx.save();
        ctx.globalAlpha = 0.22;
        ctx.fillStyle = "#b46cff";
        ctx.beginPath();
        ctx.arc(p.x, p.y, 38, 0, Math.PI*2);
        ctx.fill();
        ctx.restore();
      }

      ctx.save();
      ctx.translate(p.x, p.y);
      const t = performance.now() * 0.001;
      ctx.rotate(Math.sin(t + (p.x+p.y)*0.01) * (p.isEnemy ? 0.18 : 0.10));
      ctx.drawImage(img, -size/2, -size/2, size, size);
      ctx.restore();
    }

    function updateHUD(){
      const lvl = LEVELS[STATE.currentLevelIndex];
      ui.hudLevel.textContent = `${STATE.currentLevelIndex + 1} / ${LEVELS.length}`;
      ui.hudTime.textContent = (lvl.timeLimit >= 9000) ? "∞" : STATE.timeLeft.toFixed(1);

      const g = lvl.goal || {};
      const parts = [];
      if (g.white) parts.push(`W:${g.white}`);
      if (g.purple) parts.push(`P:${g.purple}`);
      if (g.yellow) parts.push(`Y:${g.yellow}`);
      if (g.blue) parts.push(`B:${g.blue}`);
      if (lvl.surviveSeconds && lvl.surviveSeconds > 0) parts.push(`SURVIVE:${lvl.surviveSeconds}s`);
      ui.hudGoal.textContent = parts.length ? parts.join(" ") : "—";

      const cParts = [];
      if (g.white) cParts.push(`W:${STATE.collected.white}`);
      if (g.purple) cParts.push(`P:${STATE.collected.purple}`);
      if (g.yellow) cParts.push(`Y:${STATE.collected.yellow}`);
      if (g.blue) cParts.push(`B:${STATE.collected.blue}`);
      if (lvl.surviveSeconds && lvl.surviveSeconds > 0) cParts.push(`S:${Math.min(lvl.surviveSeconds, STATE.timeSurvived).toFixed(1)}s`);
      ui.hudCollected.textContent = cParts.length ? cParts.join(" ") : "—";

      const total = levelGoalTotal(lvl);
      const got = levelCollectedForGoal(lvl);
      const pct = Math.round((got / total) * 100);
      ui.hudProgressText.textContent = pct + "%";
      ui.hudProgressFill.style.width = pct + "%";
    }

    function loop(t){
      const now = t || performance.now();
      const dt = Math.min(0.035, (now - STATE.lastT) / 1000 || 0);
      STATE.lastT = now;

      if (STATE.running){
        update(dt);
        updateHUD();
        draw();
      }
      requestAnimationFrame(loop);
    }

    window.addEventListener("keydown", (e) => {
      if (["ArrowUp","ArrowDown","ArrowLeft","ArrowRight"," "].includes(e.key)) e.preventDefault();
      STATE.keys.add(e.key);
    }, { passive:false });

    window.addEventListener("keyup", (e) => {
      STATE.keys.delete(e.key);
    });

    ui.btnStart.addEventListener("click", async () => {
      await ensureAssets();
      showLevelsMenu();
    });

    ui.btnBackToIntro.addEventListener("click", () => showIntro());

    ui.levelSelect.addEventListener("click", (e) => {
      const btn = e.target.closest("button[data-level]");
      if (!btn) return;
      const idx = Number(btn.getAttribute("data-level"));
      if (!Number.isFinite(idx) || idx < 0 || idx >= LEVELS.length) return;

      showGameScene();
      resetForLevel(idx);
      showLevelOverlay(idx);
      STATE.running = false;
    });

    ui.btnBackMenuFromLevel.addEventListener("click", () => showLevelsMenu());

    ui.btnLevelGo.addEventListener("click", () => {
      hideLevelOverlay();
      hide(ui.gameOverOverlay);
      STATE.running = true;
    });

    ui.btnRestart.addEventListener("click", () => {
      hide(ui.gameOverOverlay);
      resetForLevel(STATE.currentLevelIndex);
      showLevelOverlay(STATE.currentLevelIndex);
      STATE.running = false;
    });

    ui.btnLevels.addEventListener("click", () => showLevelsMenu());

    async function ensureAssets(){
      if (STATE.assetsReady) return;
      const [player, white, purple, yellow, blue] = await Promise.all([
        loadImage(ASSETS.player),
        loadImage(ASSETS.white),
        loadImage(ASSETS.purple),
        loadImage(ASSETS.yellow),
        loadImage(ASSETS.blue),
      ]);
      STATE.imgs = { player, white, purple, yellow, blue };
      STATE.assetsReady = true;
    }

    (function init(){
      STATE.ctx = ui.canvas.getContext("2d", { alpha: true });
      resizeCanvas();
      window.addEventListener("resize", resizeCanvas);
      requestAnimationFrame(loop);
    })();
  </script>
</body>
</html>

<script>window.scrollTo(0, 0); setTimeout(function() { window.scrollTo(0, 0); },200)</script>